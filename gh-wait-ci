#!/usr/bin/env bash
set -euo pipefail

# Wait for GitHub Actions CI to complete and report results
# Usage: gh wait-ci [run-id]
# If no run-id provided, waits for ALL runs for the current commit

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

error() { echo -e "${RED}ERROR: $*${NC}" >&2; }
info() { echo -e "${BLUE}$*${NC}"; }
success() { echo -e "${GREEN}$*${NC}"; }
warn() { echo -e "${YELLOW}$*${NC}"; }

check_git_repo() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        error "Not in a git repository"
        exit 1
    fi
}

check_pushed() {
    local unpushed
    unpushed=$(git log @{u}..HEAD --oneline 2>/dev/null || echo "")
    if [[ -n "$unpushed" ]]; then
        warn "Unpushed commits detected:"
        echo "$unpushed"
        error "Push your changes first before waiting for CI"
        exit 1
    fi
}

get_context() {
    COMMIT=$(git rev-parse HEAD)
    SHORT_COMMIT=$(git rev-parse --short HEAD)
    BRANCH=$(git branch --show-current)
    REPO=$(gh repo view --json nameWithOwner -q .nameWithOwner 2>/dev/null || echo "")

    if [[ -z "$REPO" ]]; then
        error "Could not determine GitHub repository"
        exit 1
    fi

    COMMIT_URL="https://github.com/$REPO/commit/$COMMIT"
}

print_context() {
    info "Repository: $REPO"
    info "Branch: $BRANCH"
    info "Commit: $SHORT_COMMIT"
    echo ""
}

get_pr_info() {
    PR_URL=""
    PR_NUM=""
    local pr_json
    if pr_json=$(gh pr view --json number,url 2>/dev/null); then
        PR_NUM=$(echo "$pr_json" | jq -r .number)
        PR_URL=$(echo "$pr_json" | jq -r .url)
    fi
}

find_runs() {
    local run_id="${1:-}"

    if [[ -n "$run_id" ]]; then
        RUN_IDS=("$run_id")
        info "Watching specified run: $run_id"
        return
    fi

    info "Finding workflow runs for commit $SHORT_COMMIT..."

    local runs_json run_count
    for i in {1..5}; do
        runs_json=$(gh run list --commit "$COMMIT" --json databaseId,status,conclusion,name --limit 10 2>/dev/null || echo "[]")
        run_count=$(echo "$runs_json" | jq 'length')

        if [[ "$run_count" -gt 0 ]]; then
            break
        fi

        if [[ $i -lt 5 ]]; then
            warn "No runs found yet, waiting 5 seconds... (attempt $i/5)"
            sleep 5
        fi
    done

    if [[ "$run_count" -eq 0 ]]; then
        error "No workflow runs found for commit $SHORT_COMMIT"
        exit 1
    fi

    # Store run IDs
    mapfile -t RUN_IDS < <(echo "$runs_json" | jq -r '.[].databaseId')

    info "Found $run_count workflow run(s):"
    echo "$runs_json" | jq -r '.[] | "  \(.databaseId) \(.name)"'
    echo ""
}

wait_for_runs() {
    info "Waiting for all runs to complete..."
    echo ""

    # Track status for each job: "run_id:job_name" -> "status:conclusion"
    declare -A last_job_status

    while true; do
        local all_done=true

        for run_id in "${RUN_IDS[@]}"; do
            local run_json run_status run_name
            run_json=$(gh run view "$run_id" --json status,conclusion,name,jobs 2>/dev/null || echo "{}")
            run_status=$(echo "$run_json" | jq -r '.status // "unknown"')
            run_name=$(echo "$run_json" | jq -r '.name // "unknown"')

            # Get jobs and their statuses - use process substitution to avoid subshell
            local jobs_json
            jobs_json=$(echo "$run_json" | jq -c '.jobs // []')

            while read -r job; do
                [[ -z "$job" ]] && continue
                local job_name job_status job_conclusion job_key current
                job_name=$(echo "$job" | jq -r '.name')
                job_status=$(echo "$job" | jq -r '.status')
                job_conclusion=$(echo "$job" | jq -r '.conclusion // ""')
                job_key="${run_id}:${job_name}"
                current="${job_status}:${job_conclusion}"

                # Print if changed
                if [[ "${last_job_status[$job_key]:-}" != "$current" ]]; then
                    if [[ "$job_status" == "completed" ]]; then
                        if [[ "$job_conclusion" == "success" ]]; then
                            echo "  ‚úÖ $run_name / $job_name"
                        else
                            echo "  ‚ùå $run_name / $job_name: $job_conclusion"
                        fi
                    elif [[ "$job_status" == "in_progress" ]]; then
                        echo "  üîÑ $run_name / $job_name"
                    elif [[ "$job_status" == "queued" ]]; then
                        echo "  ‚è≥ $run_name / $job_name: queued"
                    fi
                    last_job_status[$job_key]="$current"
                fi
            done < <(echo "$jobs_json" | jq -c '.[]')

            if [[ "$run_status" != "completed" ]]; then
                all_done=false
            fi
        done

        if $all_done; then
            break
        fi

        sleep 5
    done
    echo ""
}

show_results() {
    local all_success=true

    for run_id in "${RUN_IDS[@]}"; do
        local result_json conclusion name url
        result_json=$(gh run view "$run_id" --json conclusion,jobs,url,name)
        conclusion=$(echo "$result_json" | jq -r '.conclusion')
        name=$(echo "$result_json" | jq -r '.name')
        url=$(echo "$result_json" | jq -r '.url')

        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        if [[ "$conclusion" == "success" ]]; then
            success "‚úì $name PASSED"
        else
            error "‚úó $name FAILED"
            all_success=false
        fi
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        echo ""

        info "Jobs:"
        echo "$result_json" | jq -r '.jobs[] | "  \(if .conclusion == "success" then "‚úÖ" elif .conclusion == "failure" then "‚ùå" elif .conclusion == "skipped" then "‚è≠Ô∏è" else "‚è≥" end) \(.name)"'
        echo ""

        echo "     Run:  $url"

        if [[ "$conclusion" != "success" ]]; then
            warn "Failed job logs:"
            echo ""
            gh run view "$run_id" --log-failed 2>/dev/null || true
            echo ""
        fi
    done

    info "Links:"
    echo "  Commit:  $COMMIT_URL"
    [[ -n "$PR_URL" ]] && echo "      PR:  $PR_URL"
    echo ""

    $all_success
}

main() {
    check_git_repo
    check_pushed
    get_context
    print_context
    get_pr_info
    find_runs "${1:-}"
    wait_for_runs
    show_results
}

main "$@"
