#!/usr/bin/env bash
set -euo pipefail

# Wait for GitHub Actions CI to complete and report results
# Usage: gh wait-ci [run-id]
# If no run-id provided, waits for ALL runs for the current commit

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

error() { echo -e "${RED}ERROR: $*${NC}" >&2; }
info() { echo -e "${BLUE}$*${NC}"; }
success() { echo -e "${GREEN}$*${NC}"; }
warn() { echo -e "${YELLOW}$*${NC}"; }

check_git_repo() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        error "Not in a git repository"
        exit 1
    fi
}

check_pushed() {
    local unpushed
    unpushed=$(git log @{u}..HEAD --oneline 2>/dev/null || echo "")
    if [[ -n "$unpushed" ]]; then
        warn "Unpushed commits detected:"
        echo "$unpushed"
        error "Push your changes first before waiting for CI"
        exit 1
    fi
}

get_context() {
    COMMIT=$(git rev-parse HEAD)
    SHORT_COMMIT=$(git rev-parse --short HEAD)
    BRANCH=$(git branch --show-current)
    REPO=$(gh repo view --json nameWithOwner -q .nameWithOwner 2>/dev/null || echo "")

    if [[ -z "$REPO" ]]; then
        error "Could not determine GitHub repository"
        exit 1
    fi

    COMMIT_URL="https://github.com/$REPO/commit/$COMMIT"
}

print_context() {
    info "Repository: $REPO"
    info "Branch: $BRANCH"
    info "Commit: $SHORT_COMMIT"
    echo ""
}

get_pr_info() {
    PR_URL=""
    PR_NUM=""
    local pr_json
    if pr_json=$(gh pr view --json number,url 2>/dev/null); then
        PR_NUM=$(echo "$pr_json" | jq -r .number)
        PR_URL=$(echo "$pr_json" | jq -r .url)
    fi
}

find_runs() {
    local run_id="${1:-}"

    if [[ -n "$run_id" ]]; then
        RUN_IDS=("$run_id")
        info "Watching specified run: $run_id"
        return
    fi

    info "Finding workflow runs for commit $SHORT_COMMIT..."

    local runs_json run_count
    for i in {1..5}; do
        runs_json=$(gh run list --commit "$COMMIT" --json databaseId,status,conclusion,name --limit 10 2>/dev/null || echo "[]")
        run_count=$(echo "$runs_json" | jq 'length')

        if [[ "$run_count" -gt 0 ]]; then
            break
        fi

        if [[ $i -lt 5 ]]; then
            warn "No runs found yet, waiting 5 seconds... (attempt $i/5)"
            sleep 5
        fi
    done

    if [[ "$run_count" -eq 0 ]]; then
        error "No workflow runs found for commit $SHORT_COMMIT"
        exit 1
    fi

    # Store run IDs
    mapfile -t RUN_IDS < <(echo "$runs_json" | jq -r '.[].databaseId')

    info "Found $run_count workflow run(s):"
    echo "$runs_json" | jq -r '.[] | "  \(.databaseId) \(.name)"'
    echo ""
}

wait_for_runs() {
    info "Waiting for all runs to complete..."
    echo ""

    # Track previous state to detect changes
    local last_state=""
    local first_print=true

    while true; do
        local all_done=true
        local total_jobs=0
        local completed_jobs=0
        local current_state=""
        local output=""

        for run_id in "${RUN_IDS[@]}"; do
            local run_json run_status run_name
            run_json=$(gh run view "$run_id" --json status,conclusion,name,jobs 2>/dev/null || echo "{}")
            run_status=$(echo "$run_json" | jq -r '.status // "unknown"')
            run_name=$(echo "$run_json" | jq -r '.name // "unknown"')

            local jobs_json
            jobs_json=$(echo "$run_json" | jq -c '.jobs // []')

            while read -r job; do
                [[ -z "$job" ]] && continue
                local job_name job_status job_conclusion
                job_name=$(echo "$job" | jq -r '.name')
                job_status=$(echo "$job" | jq -r '.status')
                job_conclusion=$(echo "$job" | jq -r '.conclusion // ""')

                ((total_jobs++)) || true
                current_state+="${run_id}:${job_name}:${job_status}:${job_conclusion}|"

                if [[ "$job_status" == "completed" ]]; then
                    ((completed_jobs++)) || true
                    if [[ "$job_conclusion" == "success" ]]; then
                        output+="  ‚úÖ $run_name / $job_name"$'\n'
                    elif [[ "$job_conclusion" == "skipped" ]]; then
                        output+="  ‚è≠Ô∏è  $run_name / $job_name (skipped)"$'\n'
                    else
                        output+="  ‚ùå $run_name / $job_name ($job_conclusion)"$'\n'
                    fi
                elif [[ "$job_status" == "in_progress" ]]; then
                    output+="  üîÑ $run_name / $job_name"$'\n'
                elif [[ "$job_status" == "queued" || "$job_status" == "waiting" ]]; then
                    output+="  ‚è≥ $run_name / $job_name"$'\n'
                else
                    output+="  ‚è≥ $run_name / $job_name ($job_status)"$'\n'
                fi
            done < <(echo "$jobs_json" | jq -c '.[]')

            if [[ "$run_status" != "completed" ]]; then
                all_done=false
            fi
        done

        # Calculate percentage
        local percent=0
        if [[ $total_jobs -gt 0 ]]; then
            percent=$((completed_jobs * 100 / total_jobs))
        fi

        # Reprint if state changed
        if [[ "$current_state" != "$last_state" ]]; then
            if [[ "$first_print" != "true" ]]; then
                # Move cursor up and clear previous output
                local lines_to_clear=$((total_jobs + 1))
                for ((i=0; i<lines_to_clear; i++)); do
                    echo -ne "\033[A\033[2K"
                done
            fi
            first_print=false

            info "Progress: $completed_jobs/$total_jobs ($percent%)"
            echo -n "$output"
            last_state="$current_state"
        fi

        if $all_done; then
            break
        fi

        sleep 5
    done
    echo ""
}

show_results() {
    local all_success=true

    for run_id in "${RUN_IDS[@]}"; do
        local result_json conclusion name url
        result_json=$(gh run view "$run_id" --json conclusion,jobs,url,name)
        conclusion=$(echo "$result_json" | jq -r '.conclusion')
        name=$(echo "$result_json" | jq -r '.name')
        url=$(echo "$result_json" | jq -r '.url')

        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        if [[ "$conclusion" == "success" ]]; then
            success "‚úì $name PASSED"
        else
            error "‚úó $name FAILED"
            all_success=false
        fi
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        echo ""

        info "Jobs:"
        while read -r job; do
            [[ -z "$job" ]] && continue
            local job_name job_conclusion job_id icon line
            job_name=$(echo "$job" | jq -r '.name')
            job_conclusion=$(echo "$job" | jq -r '.conclusion')
            job_id=$(echo "$job" | jq -r '.databaseId')

            case "$job_conclusion" in
                success) icon="‚úÖ" ;;
                failure) icon="‚ùå" ;;
                skipped) icon="‚è≠Ô∏è " ;;
                *) icon="‚è≥" ;;
            esac

            if [[ "$job_conclusion" == "failure" ]]; then
                echo "  $icon $job_name  ‚Üí  gh run view --log --job $job_id"
            else
                echo "  $icon $job_name"
            fi
        done < <(echo "$result_json" | jq -c '.jobs[]')
        echo ""

        echo "     Run:  $url"

        if [[ "$conclusion" != "success" ]]; then
            echo ""
            warn "View all failed logs:"
            echo "  gh run view $run_id --log-failed"
            echo ""
        fi
    done

    info "Links:"
    echo "  Commit:  $COMMIT_URL"
    [[ -n "$PR_URL" ]] && echo "      PR:  $PR_URL"
    echo ""

    $all_success
}

main() {
    check_git_repo
    check_pushed
    get_context
    print_context
    get_pr_info
    find_runs "${1:-}"
    wait_for_runs
    show_results
}

main "$@"
